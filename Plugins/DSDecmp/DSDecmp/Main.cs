using System;
using System.Collections.Generic;
using System.Text;
using DSDecmp.Formats.Nitro;
using DSDecmp.Formats;
using System.IO;
using System.Xml.Linq;

namespace DSDecmp
{
    public static class Main
    {
        public static FormatsType Get_Format(string input)
        {
            CompressionFormat fmt = null;

            foreach (FormatsType f in Enum.GetValues(typeof(FormatsType)))
            {
                switch (f)
                {
                    case FormatsType.LZOVL: fmt = new LZOvl(); break;
                    case FormatsType.LZ10: fmt = new LZ10(); break;
                    case FormatsType.LZ11: fmt = new LZ11(); break;
                    case FormatsType.RLE: fmt = new RLE(); break;
                    case FormatsType.HUFF: fmt = new Huffman(); break;
                }

                if (fmt == null)
                    continue;

                if (fmt.Supports(input))
                    return f;
            }

            return FormatsType.Invalid;
        }

        #region compression methods
        public static void Compress(string input, string output, FormatsType format)
        {
            // compress the input
            MemoryStream compressedData = new MemoryStream();
            FormatsType compressedFormat;
            int outsize = DoCompress(input, compressedData, format, out compressedFormat);
            if (outsize < 0)
                return;

            using (FileStream outStream = File.Create(output))
            {
                compressedData.WriteTo(outStream);
                Console.WriteLine(String.Format(Main.Get_Traduction("S19"), compressedFormat.ToString(), input, output));
            }
        }

        public static int DoCompress(string infile, MemoryStream output, FormatsType format, out FormatsType actualFormat)
        {
            CompressionFormat fmt = null;
            switch (format)
            {
                case FormatsType.LZ10: fmt = new LZ10(); break;
                case FormatsType.LZ11: fmt = new LZ11(); break;
                case FormatsType.LZOVL: fmt = new LZOvl(); break;
                case FormatsType.RLE: fmt = new RLE(); break;
                case FormatsType.HUFF4: Huffman.CompressBlockSize = Huffman.BlockSize.FOURBIT; fmt = new Huffman(); break;
                case FormatsType.HUFF8: Huffman.CompressBlockSize = Huffman.BlockSize.EIGHTBIT; fmt = new Huffman(); break;
                case FormatsType.HUFF:
                    return CompressHuff(infile, output, out actualFormat);
                case FormatsType.GBA:
                    return CompressGBA(infile, output, out actualFormat);
                case FormatsType.NDS:
                    return CompressNDS(infile, output, out actualFormat);
                default:
                    actualFormat = FormatsType.Invalid;
                    return -1;
            }
            actualFormat = format;

            using (FileStream inStream = File.OpenRead(infile))
            {
                try
                {
                    return fmt.Compress(inStream, inStream.Length, output);
                }
                catch (Exception s)
                {
                    // any exception generated by compression is a fatal exception
                    Console.WriteLine(s.Message);
                    return -1;
                }
            }
        }

        private static int CompressHuff(string infile, MemoryStream output, out FormatsType actualFormat)
        {
            return CompressBest(infile, output, out actualFormat, FormatsType.HUFF4, FormatsType.HUFF8);
        }
        private static int CompressGBA(string infile, MemoryStream output, out FormatsType actualFormat)
        {
            return CompressBest(infile, output, out actualFormat, FormatsType.HUFF4, FormatsType.HUFF8, FormatsType.LZ10, FormatsType.RLE);
        }
        private static int CompressNDS(string infile, MemoryStream output, out FormatsType actualFormat)
        {
            return CompressBest(infile, output, out actualFormat, FormatsType.HUFF4, FormatsType.HUFF8, FormatsType.LZ10, FormatsType.LZ11, FormatsType.RLE);
        }

        private static int CompressBest(string infile, MemoryStream output, out FormatsType actualFormat, params FormatsType[] formats)
        {
            // only read the input data once from the file.
            byte[] inputData;
            using (FileStream inStream = File.OpenRead(infile))
            {
                inputData = new byte[inStream.Length];
                inStream.Read(inputData, 0, inputData.Length);
            }

            MemoryStream bestOutput = null;
            int minCompSize = int.MaxValue;
            actualFormat = FormatsType.GBA;
            foreach (FormatsType format in formats)
            {
                #region compress the file in each format, and save the best one

                MemoryStream currentOutput = new MemoryStream();
                CompressionFormat realFormat = null;
                switch (format)
                {
                    case FormatsType.HUFF4: Huffman.CompressBlockSize = Huffman.BlockSize.FOURBIT; realFormat = new Huffman(); break;
                    case FormatsType.HUFF8: Huffman.CompressBlockSize = Huffman.BlockSize.EIGHTBIT; realFormat = new Huffman(); break;
                    case FormatsType.LZ10: realFormat = new LZ10(); break;
                    case FormatsType.LZ11: realFormat = new LZ11(); break;
                    case FormatsType.LZOVL: realFormat = new LZOvl(); break;
                    case FormatsType.RLE: realFormat = new RLE(); break;
                }

                int currentOutSize;
                try
                {
                    using (MemoryStream inStream = new MemoryStream(inputData))
                    {
                        currentOutSize = realFormat.Compress(inStream, inStream.Length, currentOutput);
                    }
                }
                catch (InputTooLargeException i)
                {
                    Console.WriteLine(i.Message);
                    actualFormat = format;
                    return -1;
                }
                catch (Exception)
                {
                    continue;
                }
                if (currentOutSize < minCompSize)
                {
                    bestOutput = currentOutput;
                    minCompSize = currentOutSize;
                    actualFormat = format;
                }

                #endregion
            }

            if (bestOutput == null)
            {
                Console.WriteLine(Main.Get_Traduction("S1A"));
                return -1;
            }
            bestOutput.WriteTo(output);
            return minCompSize;
        }
        #endregion

        #region decompression methods
        public static void Decompress(string input, string output)
        {
            byte[] inData;
            using (FileStream inStream = File.OpenRead(input))
            {
                inData = new byte[inStream.Length];
                inStream.Read(inData, 0, inData.Length);
            }

            MemoryStream decompressedData = new MemoryStream();
            long decSize = -1;
            FormatsType usedFormat = FormatsType.NDS;
            // just try all formats, and stop once one has been found that can decompress it.
            foreach (FormatsType f in Enum.GetValues(typeof(FormatsType)))
            {
                using (MemoryStream inStream = new MemoryStream(inData))
                {
                    decSize = Decompress(inStream, decompressedData, f);
                    if (decSize >= 0)
                    {
                        usedFormat = f;
                        break;
                    }
                }
            }
            if (decSize < 0)
            {
                Console.WriteLine(String.Format(Main.Get_Traduction("S1B"), input));
                return;
            }

            byte[] outData = decompressedData.ToArray();
            using (FileStream outStream = File.Create(output))
            {
                outStream.Write(outData, 0, outData.Length);
                Console.WriteLine(String.Format(Main.Get_Traduction("S1C"), usedFormat.ToString(), input, output));
            }

        }
        public static void Decompress(string input, string output, FormatsType format)
        {
            byte[] inData;
            using (FileStream inStream = File.OpenRead(input))
            {
                inData = new byte[inStream.Length];
                inStream.Read(inData, 0, inData.Length);
            }

            MemoryStream decompressedData = new MemoryStream();
            long decSize = -1;
            // just try all formats, and stop once one has been found that can decompress it.
            using (MemoryStream inStream = new MemoryStream(inData))
            {
                decSize = Decompress(inStream, decompressedData, format);
            }
            if (decSize < 0)
            {
                Console.WriteLine(String.Format(Main.Get_Traduction("S1B"), input));
                return;
            }

            byte[] outData = decompressedData.ToArray();
            using (FileStream outStream = File.Create(output))
            {
                outStream.Write(outData, 0, outData.Length);
                Console.WriteLine(String.Format(Main.Get_Traduction("S1C"), format.ToString(), input, output));
            }

        }
        private static long Decompress(MemoryStream inputStream, MemoryStream output, FormatsType format)
        {
            CompressionFormat realFormat = null;
            switch (format)
            {
                case FormatsType.HUFF:
                    realFormat = new Huffman(); break;
                case FormatsType.LZ10:
                    realFormat = new LZ10(); break;
                case FormatsType.LZ11:
                    realFormat = new LZ11(); break;
                case FormatsType.LZOVL:
                    realFormat = new LZOvl(); break;
                case FormatsType.RLE:
                    realFormat = new RLE(); break;
                default:
                    return -1;
            }
            if (!realFormat.Supports(inputStream, inputStream.Length))
                return -1;
            try
            {
                return realFormat.Decompress(inputStream, inputStream.Length, output);
            }
            catch (TooMuchInputException e)
            {
                Console.WriteLine(e.Message);
                return output.Length;
            }
            catch (Exception e)
            {
                Console.WriteLine(String.Format(Main.Get_Traduction("S1D"), format.ToString(), e.Message));
                return -1;
            }
        }
        #endregion

        internal static string Get_Traduction(string code)
        {
            String message = "";
            try
            {
                XElement xml = XElement.Load(System.Windows.Forms.Application.StartupPath + Path.DirectorySeparatorChar + "Tinke.xml");
                string idioma = xml.Element("Options").Element("Language").Value;
                xml = null;

                foreach (string langFile in Directory.GetFiles(System.Windows.Forms.Application.StartupPath + Path.DirectorySeparatorChar + "langs"))
                {
                    if (!langFile.EndsWith(".xml"))
                        continue;

                    xml = XElement.Load(langFile);
                    if (xml.Attribute("name").Value == idioma)
                        break;
                }

                message = xml.Element("DSDecmp").Element(code).Value;
            }
            catch { throw new Exception("There was an error in the XML file of language."); }

            return message;
        }
        internal static XElement Get_Traduction()
        {
            XElement tree = null;
            try
            {
                XElement xml = XElement.Load(System.Windows.Forms.Application.StartupPath + Path.DirectorySeparatorChar + "Tinke.xml");
                string idioma = xml.Element("Options").Element("Language").Value;
                xml = null;

                foreach (string langFile in Directory.GetFiles(System.Windows.Forms.Application.StartupPath + Path.DirectorySeparatorChar + "langs"))
                {
                    if (!langFile.EndsWith(".xml"))
                        continue;

                    xml = XElement.Load(langFile);
                    if (xml.Attribute("name").Value == idioma)
                        break;
                }

                tree = xml.Element("DSDecmp");
            }
            catch { throw new Exception("There was an error in the XML file of language."); }

            return tree;
        }
    }

    /// <summary>
    /// The formats allowed when compressing a file.
    /// </summary>
    public enum FormatsType
    {
        LZOVL, // keep this as the first one, as only the end of a file may be LZ-ovl-compressed (and overlay files are oftenly double-compressed)
        LZ10,
        LZ11,
        HUFF4,
        HUFF8,
        RLE,
        HUFF,
        NDS,
        GBA,
        Invalid
    }
}
