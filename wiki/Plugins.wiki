#summary Información sobre los plugins de Tinke

Una de las grandes ventajas de Tinke es su sistema de plugins, a través del cual se puede fácilmente soportar cualquier formato de archivo, sin tener que tocar el código del programa. De esta forma cualquier persona puede crear un plugin que será tan sencillo como crear una librería (.DLL) donde haya una clase que herede una interfaz. Más tarde tan sólo incluyendo esta librería en la carpeta Plugins del programa será leido e iniciado el soporte.
El plugin debe estar escrito en cualquier lenguaje de .NET Framework 3.5 (C#, VB.NET)

=Clases de plugins=

Actualmente hay dos tipos de plugins:

[*]Formato: son plugins que soportan un tipo de formato para cualquier juego. Heredan la interfaz IPlugin
[*]Juego: son plugins donde sólo actuaran y darán soporte al juego que se especifique. Heredan la interfaz IGamePlugin.

La causa de que exista el segundo formato es porque hay muchos archivos (como .bin o .arc) que difieren mucho su contenido entre cada juego, de esta forma en un juego el formato .arc puede ser un archivo comprimido y en otro una imagen con animaciones. Por ello el segundo plugin actuará sólo en los juegos que soporte (generalmente todas las regiones de un mismo juego o saga) y tendrá preferencia sobre el plugin Formato.

=Interfaz IPlugin=

Los métodos que un plugin _Formato_ debe heredar de la interfaz IPlugin son cuatro:

{{{
public void Inicializar(IPluginHost pluginHost);
public PluginInterface.Formato Get`_`Formato(string nombre, byte`[``]` magic);
public void Leer(string archivo, int id);
public System.Windows.Forms.Control Show`_`Info(string archivo, int id);
}}}

El método _Inicializar_ aporta la clase IPluginHost para poder tener enlace con el programa Host (Tinke). En él hay métodos más usados para facilitar la tarea al programador. Es el primer método que se llama en el plugin.

La función _Get`_`Formato_ se llama para saber si el archivo _String_ que se pasa es compatible con ese plugin. El argumento _magic_ corresponde a los primeros 4 bytes del archivo que generalmente contiene el ID del archivo. Para convertirlo a String se puede hacer de la siguiente forma:
{{{
String ext = new String(System.Text.Encoding.ASCII.GetChars(magic));
}}}

El método _Leer_ se llama cuando se hace doble click sobre un archivo. El objetivo de éste método es guardar la información de archivos necesarios para formar otros archivos, por ejemplo, para guardar una paleta sin tener que pulsar el botón Ver, más tarde otro plugin puede obtener esta información guardada. De esta forma se agiliza la visualización de archivos. El argumento ID se pasa para asignarlo a las estructuras que se guardan, se necesita este ID para que otros plugins puedan localizar este archivo para modificarlo.

La función Show`_`Info devuelve el control con toda la información posible del archivo, se llama cuando se pulsa el botón Ver. El argumento ID tiene la misma función que en el método anterior.

*Archivos comprimidos*: Un dato importante a la hora de crear plugins para archivos comprimidos (tanto contenedores como compresiones) es que al pulsar el botón Descomprimir se llama al método Leer. Además para que el sistema pueda tener acceso a los archivos descomprimidos y añadirlos al árbol principal, estos archivos descomprimidos deben guardarse en el método Set_Files(Carpeta archivos) de la interfaz iPluginHost que se pasa al inicializar el plugin.

=Interfaz IGamePlugin=

Los métodos que un plugin _Juego_ debe heredar de la interfaz IGamePlugin son cinco:

{{{
public void Inicializar(IPluginHost pluginHost, string gameCode);
public PluginInterface.Formato Get`_`Formato(string nombre, byte`[``]` magic, int id);
public void Leer(string archivo, int id);
public System.Windows.Forms.Control Show`_`Info(string archivo, int id);
public bool EsCompatible();
}}}

Los cuatro primeros métodos son iguales a los de la interfaz anterior con la diferencia de que se pasa siempre el ID del archivo para poder reconocer archivos del juego por ID. También en el método _Inicializar_ se da un String del juego actual.

El quinto método _EsCompatible_ sirve para saber si el plugin actual soporta ese juego, para ello se emplea el gameCode pasado al inicalizar el plugin.

=IPluginHost=

Mediante el método Inicializar se pasa la variable _pluginHost_ que es una clase heredada de la interfaz IPluginHost. Esta variable sirve de vínculo con el programa principal proporciando métodos y funciones. La mayoría sirven para ahorra mucho tiempo a la hora de crear plugins.

{{{
NCLR Get_NCLR();		    // Obtiene la información de un archivo de paletas
NCGR Get_NCGR();			// Obtiene la información de un archivo de tiles
NSCR Get_NSCR();			// Obtiene la información de un archivo de map
NCER Get_NCER();			// Obtiene la información de un archivo de celdas
NANR Get_NANR();			// Obtiene la información de un archivo de animaciones

void Set_NCLR(NCLR nclr);   // Guarda la información de un archivo de paletas
void Set_NCGR(NCGR ncgr);   // Guarda la información de un archivo de tiles
void Set_NSCR(NSCR nscr);	// Guarda la información de un archivo de map
void Set_NCER(NCER ncer);   // Guarda la información de un archivo de celdas
void Set_NANR(NANR nanr);   // Guarda la información de un archivo de animaciones

Color[] BGR555(byte[] data);	// Descodifica bytes en colores usando la codificación BGR555
Byte[] ColorToBGR555(Color[] color);	// Codifica colores en bytes usando la codificación BGR555
Byte[] BytesTo4BitsRev(byte[] datos);	// Convierte una array de bytes en 4-bit y le da la vuelta (usado en imágenes)
String BytesToBits(byte[] datos);	// Convierte una array de bytes en bits (contenido en una string)
Byte[] Bit4ToBit8(byte[] bits4);	// Convierte bytes en formato 4-bit en formato 8-bit (usado en imágenes)
Byte[] Bit8ToBit4(byte[] bits8);	// Convierte bytes en formato 8-bit en formato 4-bit (usado en imágenes)
Byte[] TilesToBytes(byte[][] tiles);	// Convierte tiles (NCGR.rahc.tileData.tiles) en bytes (byte[][] a byte[])
Byte[][] BytesToTiles(byte[] bytes);    // Convierte bytes en tiles (NCGR.rahc.tileData.tiles) (byte[] a byte[][])
Byte[][] BytesToTiles_NoChanged(byte[] bytes, int tilesX, int tilesY);	// Convierte bytes en tiles (NCGR.rahc.tileData.tiles) sin que la imagen cambie (conversión especial No_Tiled to Horizontal
TTLP Palette_4bppTo8bpp(TTLP palette);	// Convierte una paleta de profundidad 4bpp a 8bpp
TTLP Palette_8bppTo4bpp(TTLP palette);  // Convierte una paleta de profundidad 8bpp a 4bpp

Bitmap[] Bitmaps_NCLR(string archivo);  // Obtiene de un archivo NCLR las paletas y las devuelve en imagen
Bitmap[] Bitmaps_NCLR(NCLR nclr);		// Devuelva la imágen de las paletas de un archivo NCLR
Bitmap Bitmap_NCGR(NCGR ncgr, NCLR nclr);	// Crea una imagen a partir tiles y una paleta
Bitmap Bitmap_NCGR(NCGR ncgr, NCLR nclr, int startTile); // Crea una imagen a partir tiles y una paleta
Bitmap Bitmap_NCGR(NCGR ncgr, NCLR nclr, int startTile, int tilesX, int tilesY);	// Crea una imagen a partir de tiles y una paleta
NTFT Transformar_NSCR(NSCR nscr, NTFT ntft);	// Transforma unos tiles según la información de una estructura map
Size Tamaño_NCER(byte byte1, byte byte2);	// Obtiene el tamaño de una celda según los bytes que presenta
Bitmap Bitmap_NCER(Bank banco, uint blockSize, NCGR ncgr, NCLR nclr, bool entorno, bool celda, bool numero, bool transparencia, bool imagen);	// Obtiene la imagen de una celda
void Crear_APNG(string salida, Bitmap[] frames, int delay, int loops);	// Crea una animación en formato APNG
void Crear_APNG(string salida, String[] frames, int delay, int loops);	// Crea una animación en formato APNG

void Set_Files(Carpeta archivos);	// Guarda archivos descomprimidos
Carpeta Get_Files();				// Obtiene archivos descomprimidos

string Get_Language();		// Obtiene el lenguaje actual
string Get_TempFolder();	// Obtiene la carpeta temporal del programa

/* Descomprime datos usando las compresiones comunes (LZ77, huffman) y llamando a otro plugins */
void Descomprimir(string archivo);
void Descomprimir(byte[] datos);
void Descomprimir(byte[] datos, byte tag);


void ChangeFile(int id, string newFile);	// Cambia el contenido de un archivo

void Write_NCLR(NCLR nclr, string fileout);	// Escribe una estructura NCLR a un archivo
void Write_NCGR(NCGR ncgr, string fileout);	// Escribe una estructura NCGR a un archivo
void Write_NSCR(NSCR nscr, string fileout);	// Escribe una estructura NSCR a un archivo

NCLR BitmapToPalette(string bitmap);	// Obtiene una imagen Bitmap su paleta (en el caso de que su profundidad sea 4bpp ó 8bpp)
NCGR BitmapToTile(string bitmap, Orden_Tiles tileOrder);	// Obtiene de una imagen Bitmap sus tiles (en el caso de que su profundidad sea 4bpp ó 8bpp)
NSCR Create_BasicMap(int nTiles, int width, int height);	// Crea una estructura MAP básica
}}}